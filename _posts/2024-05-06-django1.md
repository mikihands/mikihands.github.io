---
layout: post
title:  "Django에서 다중 앱 구성의 이해"
date:   2024-05-06 01:44:00 +0900
categories: Django
tags: Django Framework python 장고
---

![image](/assets/images/postings/Djago1_1.jpg)

## 한 부모에서 태어난 여러개의 앱들의 상호작용

Django 프로젝트에서 여러 앱을 만들 때, 각 앱은 기본적으로 독립적으로 기능할 수 있도록 설계됩니다. 이것은 Django의 설계 철학 중 하나로, 앱을 모듈화하여 각각이 독립적으로 작동하고 재사용 가능하도록 하는 것입니다. 그러나 앱들은 프로젝트의 다른 부분과 상호작용하며 통합될 수 있습니다. 다음은 이에 대한 좀 더 구체적인 설명입니다:

### 각 앱의 독립성

1. **독립적인 기능**: 각 Django 앱은 특정 기능을 수행하도록 설계될 수 있으며, 데이터 모델, 뷰, 템플릿, 폼, API 등을 포함할 수 있습니다. 예를 들어, A 앱이 사용자 관리를 담당하고, B 앱이 블로그 포스팅 기능을 관리할 수 있습니다.
2. **독립적인 개발과 테스트**: 각 앱은 다른 앱과 독립적으로 개발하고 테스트할 수 있습니다. 이는 각 앱이 자체적인 기능과 로직을 가지며, 다른 앱의 변경 없이 개선이나 수정이 가능함을 의미합니다.

### 앱 간의 상호작용

1. **모델 연결**: 하나의 앱에서 정의된 모델을 다른 앱에서 참조할 수 있습니다. 예를 들어, B 앱에서 A 앱의 사용자 모델을 외래 키로 사용하여 사용자가 작성한 블로그 포스트를 관리할 수 있습니다.
2. **프로젝트 설정 공유**: 모든 앱은 동일한 `settings.py` 파일의 설정을 공유합니다. 이는 데이터베이스 설정, 미들웨어, 템플릿 설정 등을 포함할 수 있습니다.
3. **URL 라우팅**: 프로젝트의 `urls.py` 파일에서 각 앱의 URL을 포함시켜서 통합된 URL 네임스페이스를 관리할 수 있습니다. 이를 통해 프로젝트 내에서 서로 다른 앱의 뷰로 라우팅을 할 수 있습니다.

### 배포 관점에서의 독립성과 상호작용

배포할 때, Django 프로젝트는 일반적으로 하나의 웹 애플리케이션으로 처리됩니다. 그러나 앱별로 독립적인 설정이나 데이터베이스를 구성하는 것도 가능하며, 이는 프로젝트의 `settings.py`에서 관리됩니다.

결론적으로, Django에서 A와 B 앱은 기본적으로 독립적으로 기능할 수 있지만, 필요에 따라 서로 상호작용하며 프로젝트 전체의 일부로 통합될 수 있습니다. 이러한 구조는 Django의 유연성과 확장성을 크게 증진시킵니다.

예를 들어서 설명을 해보겠습니다. 예를 들어, my_project라는 이름의 프로젝트 아래에 `Wep_app` 이라는  앱을 만들어 배포하였는데, 동일한 my_project 프로젝트 아래에서 `Mobile_app` 이라는 앱을 만들수도 있고, `myblog`라는 앱을 만들 수도 있다는 것입니다.  클라이언트 들이 볼 때는 각각의 앱은 각각의 도메인을 가지고 독립적으로 운영되는 것처럼 보이지만, 백엔드에서는 이 세가지 앱이 서로의 기능을 참조하거나 이용하게 쉽게 커스터마이징이 가능한 상태인 것입니다. 

이렇게 Django에서는 하나의 프로젝트 아래에 여러 앱을 만들어 각각의 독립된 기능을 수행하게 할 수 있고, 필요에 따라 이 앱들이 서로 상호작용하도록 설계할 수 있습니다. 하나의 프로젝트 산하의 다수 개의 어플리케이션 들은 독립적인 기능을 제공하면서도, 필요에 따라 서로 데이터를 공유하거나 기능을 연동할 수 있습니다.

### 각 앱의 독립적 운영과 상호 연동

- **도메인 분리**: 각 앱은 독립된 도메인 또는 서브도메인에 배포될 수 있어서 사용자는 이들이 완전히 분리된 서비스처럼 느낄 수 있습니다. 예를 들어, `web.example.com`, `mobile.example.com`, `blog.example.com` 같은 식으로 구성할 수 있습니다.
- **백엔드 상호작용**: 백엔드에서는 이 앱들이 같은 데이터베이스를 공유하거나, 같은 서버 리소스를 사용하는 등 서로 긴밀하게 연동되어 작동할 수 있습니다. 예를 들어, `Web_app`에서 생성된 데이터를 `mobile_app`에서도 활용할 수 있고, `myblog`에서 생성된 콘텐츠를 `Web_app`에서 활용하는 등의 상호 작용이 가능합니다.

### 클라이언트와 서버의 관점

- **클라이언트 관점**: 사용자 또는 클라이언트는 각 앱이 독립적으로 서비스되고 있는 것처럼 인식하며, 각 앱의 도메인을 통해 접근할 수 있습니다.
- **서버 관점**: 서버 측면에서는 이 모든 앱이 하나의 프로젝트 구조 안에서 관리되므로, 코드 재사용, 유지보수, 업데이트 등이 용이하며, 앱 간 데이터 공유 및 기능 호출이 간편합니다.

이처럼 Django는 각 앱이 독립적으로도 잘 작동하면서 필요에 따라 서로 협력할 수 있는 구조를 제공하여, 대규모 프로젝트에서도 효율적인 개발과 운영을 가능하게 합니다. 이를 통해 다양한 클라이언트 요구 사항과 비즈니스 요건을 효과적으로 충족시킬 수 있습니다.



## DATABASE는 어떻게 운영되는가?

![image](/assets/images/postings/Django1_3.jpg)

**Django**에서는 각 앱이 서로 다른 데이터베이스를 사용할 수 있도록 설정하는 것이 가능합니다. 이를 통해 앱 각각의 데이터를 독립적으로 관리할 수 있으며, 이는 특히 서로 다른 유형의 데이터를 처리해야 할 때 유용할 수 있습니다.

### 다중 데이터베이스 설정 방법

Django에서 다중 데이터베이스를 설정하는 방법은 `settings.py` 파일에서 `DATABASES` 설정을 통해 여러 데이터베이스를 정의하고, 각 모델이 어느 데이터베이스를 사용할지를 지정하는 것을 포함합니다. 이를 위해 몇 가지 주요 설정과 단계를 따라야 합니다:


1. **데이터베이스 설정**: `settings.py`에서 여러 데이터베이스 연결을 정의합니다.

```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': 'mydefaultdatabase',
    },
    'webapp': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'webapp_db',
        'USER': 'webapp_user',
        'PASSWORD': 'your_password',
        'HOST': 'localhost',
        'PORT': '',
    },
    'mobileapp': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'mobileapp_db',
        'USER': 'mobileapp_user',
        'PASSWORD': 'your_password',
        'HOST': 'localhost',
        'PORT': '',
    }
}
```

1. **데이터베이스 라우터 설정**: 데이터베이스 라우터를 사용하여 각 모델이 어떤 데이터베이스를 사용할지 결정합니다. 이를 위해 `DATABASE_ROUTERS` 값을 설정 파일에 추가합니다. 데이터베이스 라우터는 `allow_migrate`, `db_for_read`, `db_for_write` 등의 메서드를 구현해야 합니다.

```python
class AppRouter:
    def db_for_read(self, model, **hints):
        if model._meta.app_label == 'webapp':
            return 'webapp'
        elif model._meta.app_label == 'mobileapp':
            return 'mobileapp'
        return 'default'

    def db_for_write(self, model, **hints):
        return self.db_for_read(model, **hints)

    def allow_migrate(self, db, app_label, model_name=None, **hints):
        if app_label == 'webapp':
            return db == 'webapp'
        elif app_label == 'mobileapp':
            return db == 'mobileapp'
        return db == 'default'
```

1. **`settings.py`에 라우터 추가**:

```python
DATABASE_ROUTERS = ['path.to.AppRouter']
```

### 주의 사항

- 각 데이터베이스 간의 관계(예: 외래 키)는 동일한 데이터베이스 내에서만 유효합니다. 서로 다른 데이터베이스 간의 직접적인 관계를 설정하는 것은 지원되지 않습니다.
- 데이터베이스간의 데이터 동기화나 마이그레이션 작업은 추가적인 로직을 필요로 할 수 있습니다.

이러한 설정을 통해 각 Django 앱이 필요에 따라 서로 다른 데이터베이스를 사용하면서도 하나의 프로젝트 안에서 효율적으로 관리될 수 있습니다.



## SuperUser 관리자의 관리화면은 어떻게 되는 걸까?

![image](/assets/images/postings/Django1_2.jpg)

**Django**의 관리자 사이트는 매우 유연하게 구성할 수 있으며, 모든 앱의 모델을 하나의 관리자 인터페이스에서 관리할 수 있습니다. 기본적으로 **Django**는 하나의 관리자 사이트를 제공하며, 이를 통해 등록된 모든 앱의 데이터 모델을 관리할 수 있습니다. 여러 앱이 있더라도, 각 앱의 모델을 관리자 사이트에 등록하기만 하면 됩니다.

### 관리자 사이트 설정

1. **모델 등록**: 각 앱의 `admin.py` 파일에서 해당 앱의 모델을 관리자 사이트에 등록할 수 있습니다. 예를 들어, `Web_app`과 `mobile_app` 앱에서 각각의 모델을 등록하는 코드는 다음과 같이 작성할 수 있습니다.

```python
# Web_app/admin.py
from django.contrib import admin
from .models import WebModel

admin.site.register(WebModel)

# mobile_app/admin.py
from django.contrib import admin
from .models import MobileModel

admin.site.register(MobileModel)
```

1. **관리자 사이트 커스터마이징**: 관리자 사이트의 모양과 느낌을 변경하기 위해 관리자 클래스를 사용할 수 있습니다. 이를 통해 리스트 페이지의 필터, 검색 필드, 표시할 필드 등을 정의할 수 있습니다.

```python
from django.contrib import admin
from .models import WebModel

class WebModelAdmin(admin.ModelAdmin):
    list_display = ('name', 'active', 'updated')
    list_filter = ('active',)
    search_fields = ('name',)

admin.site.register(WebModel, WebModelAdmin)
```

### 관리자 사이트의 동작 방식

- **단일 접근점**: Django 관리자 사이트는 `/admin/` URL에서 접근할 수 있으며, 이곳에서 모든 앱의 데이터를 관리할 수 있습니다.
- **사용자 권한**: 관리자 사이트는 사용자 권한을 기반으로 데이터를 보거나 수정할 수 있는 권한을 제어할 수 있습니다. 수퍼유저는 모든 데이터에 대한 접근 권한을 갖지만, 다른 관리자 사용자는 특정 앱이나 모델에 대해서만 권한을 부여받을 수 있습니다.
- **앱 구분**: 관리자 페이지에서 각 앱은 명확하게 구분되어 표시되며, 사용자는 앱별로 모델 데이터를 쉽게 찾아볼 수 있습니다.

### 다중 데이터베이스 환경

- 다중 데이터베이스를 사용하는 환경에서도, 관리자 사이트는 데이터베이스 라우터 설정에 따라 올바른 데이터베이스의 데이터를 쿼리하게 됩니다. 모델이 특정 데이터베이스에 할당되어 있다면, 관리자 인터페이스는 이 설정을 따라 해당 데이터를 처리합니다.

이처럼 Django의 관리자 사이트는 프로젝트의 모든 앱을 아우르는 중앙 집중식 관리 도구로서, 여러 앱이 포함된 복잡한 프로젝트에서도 효과적으로 데이터 관리를 할 수 있도록 설계되어 있습니다.





## 프로젝트에 두 개 이상의 앱이 있을 때 부분 배포는 가능한가?



> 하나의 장고 프로젝트에서 두 개 이상의 앱이 있을 때, 하나의 앱이 완성되었을 때, 그 하나만 일단은 퍼블리싱을 할 수가 있을까요?



**Django** 프로젝트에서 여러 앱이 있을 때 각 앱을 독립적으로 배포하는 것은 직접적으로 지원되지 않습니다. **Django**의 설계 철학은 프로젝트 전체를 하나의 단위로 보고, 이를 통째로 배포하는 것입니다. 그러나 특정 앱의 기능을 먼저 완성하고 싶다면, ***그 앱에 해당하는 부분만 사용자에게 노출하고 나머지는 숨긴 채로 서비스***를 시작할 수는 있습니다. 이를 위해 몇 가지 방법을 사용할 수 있습니다:

### 특정 앱 기능의 배포 전략

1. **URL 설정**: 프로젝트의 `urls.py`에서 특정 앱의 URL만 활성화하고 나머지는 주석 처리하거나 제외할 수 있습니다. 이렇게 하면 완성된 앱 관련 기능만 접근 가능하며, 나머지는 접근할 수 없게 됩니다.

```py
# project/urls.py
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('app1/', include('app1.urls')),  # 활성화된 앱
    # path('app2/', include('app2.urls')),  # 비활성화된 앱
]
```

1. **기능 플래그 사용**: 특정 기능이나 앱을 활성화하거나 비활성화할 수 있는 기능 플래그를 구현합니다. 이를 통해 설정을 변경함으로써 앱의 동작을 제어할 수 있습니다.
2. **배포 환경 분리**: 개발 중인 앱을 스테이징 서버에서만 사용하도록 하고, 완성된 앱만 실제 프로덕션 환경에서 사용하도록 구성할 수 있습니다.

### 독립적인 앱의 배포를 위한 고려사항

- **데이터베이스 마이그레이션**: 완성된 앱에 필요한 데이터베이스 마이그레이션만 실행되도록 해야 할 수도 있습니다. 이는 `migrate` 명령어를 사용할 때 특정 앱을 명시하여 처리할 수 있습니다.

```bash
python manage.py migrate app1
```

- **정적 파일 관리**: 완성된 앱의 정적 파일만 프로덕션 서버에 배포하고 싶을 수 있습니다. `collectstatic` 명령어를 사용할 때 특정 앱의 정적 파일만 처리하는 것은 Django에서 직접적으로 지원하지 않으므로, 스크립트나 도구를 통해 관리해야 합니다.
- **보안 및 접근 제어**: 완성되지 않은 앱의 기능이 외부에 노출되지 않도록 주의해야 합니다. 로그인 필요, 특정 사용자 그룹 접근 제한 등의 보안 조치를 적용해야 할 수 있습니다.

Django 프로젝트에서는 일반적으로 전체 애플리케이션을 한 번에 배포하지만, 특정 앱 또는 기능에 대한 접근을 제어하거나 배포하는 방식으로 운영할 수 있습니다. 이는 프로젝트의 설정과 필요에 따라 조정할 수 있습니다.